a:0
b:1
---
a:0
====
-> rm b


a:0
---
b:0
====
-> mv b a


a:0
b:0
----
a:0
====
-> local_cp a b


a:0
b:1
---
a:0
====
-> remote_cp b

Startégie:
mv, local_cp, remote_cp, local_cp
remote_cp, local_cp, mv
PB:

a:0
b:1
---
a:1
b:0
=====
mv a b # NON ! écrase b qui sert pour a

Idée: toute action qui crée un fichier (local_cp, remote_cp et mv) ajoute une extension temporaire.
Une fois toutes les actions effectuées, on renomme tous les fichiers pour retirer l'etension

Rq: rm n'est pas safe:

a:0
b:1
----
a:1
===
mv b a
ICI l'algo détectera qu'il faut effacer a -> Ne pas faire les suppressions à la fin!




RECAP:

Fichiers seulement sur dst: RM
Slt sur src: remote_cp (avec extension)
mv ce qu'il reste, local_cp si plus sur src, rm si plus sur dst
Renommer tous les fichiers avec l'extension en leur nom définitif

======================================

10/02/2021
Cette approche n'est pas viable: il faut pouvoir hasher sur l'hôte.
Idée:
Créer un ficher rapport sur l'hote de la source et sur l'hote de dest
Les comparer et copier le nécessaire
-> Il faut hasher TOUS les fichiers...

Autre idée:
On crée les deux rapports (sans checksum), on compare et on cherche les
collisions. On envoie la liste des fichiers dont il faut calculer la checksum
sur l'hôte distant.


-> Trop d'opérations manuelles. Il faut que le programme puisse agir comme
client et comme serveur...




======================================


Actions:

src:
[A(1), B(2), C(3), D(4), G(1), H(6), I(6)]
dst:
[B(1), A(2), E(3), F(5)]


groups: [([A,G],[B]), ([B],[A]), ([C],[E]), ([D],[]),([],[F]), ([H, I],[])]

rm: [F]
local_cp_pre: [(B,G)]
mv: [(A,B), (E,C), (B,A)]
remote_cp: [D, H]
local_cp_post:[(H,I)]

=========================================

17/03/2021

Comment récupérer les infos sur les fichiers distants ?

Script myrror-server.py:
  Permet de détecter les fichiers sur la machine actuelle,
  calculer les propriétés d'une liste de fichiers et générer un Pickle/json
  pour répondre à des requêtes. DOIT garder une table
  (nom, chemin, date) -> checksums pour permettre une réponse rapide
  Ce code sera executé sur la cible via ssh depuis l'hôte. Il envoie
  (via stdout?) les data serialisée nécessaires.
  L'hôte recréera ou enrichiera alors en local les classes Remote_file


Exemple :
  python myrror-server.py get_files "/some/path"
  ['f1','f2',...]

  host$ scp flist remote:flist
  remote$ python myrror-server.py get_qhash flist
  {'f1':'123...','f2':'456...',...}

Nécessaire de passer les noms de fichiers autrement que par la ligne de commande
(limite en nb de char). Par ex scp un txt/pickle au préalable
